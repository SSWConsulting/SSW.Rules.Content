---
type: rule
archivedreason: 
title: Do you know when to use GraphQL?
guid: 543dd6a0-a206-4ffe-b2b4-bdf8061a1c5f
uri: do-you-know-when-to-use-graphql
created: 2020-10-21T18:35:01.0000000Z
authors:
- id: 1
  title: Adam Cogan
- id: 97
  title: Matt Goldman
related: []

---


<p>​GraphQL is a query language for your APIs. It lets you expose a schema, which is a combination of 
<strong>types</strong>, 
<strong>queries,</strong> and 
<strong>mutations&#160;</strong>and your client applications can define their own queries based on that schema. You can think of it as SQL for the web.</p><p>GraphQL was developed by Facebook in 2012 to solve a problem with their mobile app, which was chewing users' data and battery and leading to negative reviews. This is because the Facebook newsfeed combines data from many entities and data sources, which required multiple API calls. GraphQL allowed them to retrieve all the data they need with 1 call. Facebook open-sourced the GraphQL specification in 2015 (<a href="http&#58;//spec.graphql.org/June2018/">http&#58;//spec.graphql.org/June2018/</a>).<br></p>
<br><excerpt class='endintro'></excerpt><br>
<p>GraphQL is a query language; it is agnostic of&#160;database, programming language, OS, and platforms. There are GraphQL server and client libraries for nearly all of these (see the Resources section below), which you can add to your existing projects to enable GraphQL.<br></p><h3 class="ssw15-rteElement-H3">​Key Terms</h3><p>GraphQL differs from REST in that REST is concerned with&#160;<b>resources</b> and GraphQL is concerned with&#160;<b>state</b>. While some features are somewhat analogous, it helps to be familiar with the GraphQL lingo and understand it in its own right. For more information, see&#58; 
   <a href="https&#58;//graphql.org/learn/thinking-in-graphs/">https&#58;//graphql.org/learn/thinking-in-graphs/​</a><br><br></p><ul><li>
      <b>Types&#58;</b> Types are the fundamental building blocks of your GraphQL API. Just like in a strongly typed language like C#, there are a default set of types, and you build your own by putting together default and custom types as&#160;<b>fields</b>&#160;of other types. See&#58; 
      <a href="https&#58;//graphql.org/learn/schema/#type-system">https&#58;//graphql.org/learn/schema/#type-system</a></li><li>
      <b>Queries&#58;</b> GraphQL queries return the current state of the data source(s). Being a query language, you specify which fields you want the server to return – these can be any fields supported by the schema, including for related types. Your query is interpreted by the server and used to fetch data to pass back to the requesting client. One of the most powerful features of GraphQL is not just that it doesn’t care what the data source is, but&#160;<b>schema stitching</b> allows you to aggregate data from multiple sources and return it to your client with one query. Those data sources could be different entities or database tables, different databases, or even flat files on a server, or other GraphQL (or REST) APIs. See&#58; 
      <a href="https&#58;//graphql.org/learn/queries/">https&#58;//graphql.org/learn/queries/</a></li><li>
      <b>Mutations&#58;</b> Mutations change the state of the data source(s) that the GraphQL server exposes, similar to create, update, or delete operations. See&#58; 
      <a href="https&#58;//graphql.org/learn/queries/#mutations">https&#58;//graphql.org/learn/queries/#mutations</a></li><li>
      <b>Schema&#58;</b> Your GraphQL schema is the complete map of data your GraphQL server exposes. This defines all the data that your clients can request, and all the changes they can make. Specific queries or mutations are not explicitly defined;&#160;rather, you specify their structure. Just like with a SQL database, you write whatever queries you want against it, and if the schema supports them, they will run successfully.<br></li></ul><h3 class="ssw15-rteElement-H3">Advantages of GraphQL​​<br></h3><ul><li>
      <b>No under-fetching&#58;</b> Sometimes a REST resource may only give you part of what you need. For example, if you need to know all the orders placed by a customer, what date they were ordered, and their current status, but the initial customer search resource only returns the details of the customer, this is called under-fetching. You then need to use the customer’s ID to query your orders resource for all orders matching that customer ID.</li></ul><dl class="badImage"><dt><img src="/SiteAssets/graphql-when-to-use/graphql-bad-example-underfetching.png" alt="graphql-bad-example-underfetching.png" style="margin&#58;5px;width&#58;750px;height&#58;495px;" /><br></dt><dd>Figure&#58; Bad Example – REST API does not return order information with a customer query, so a second API call is needed<br></dd></dl><ul><li>​<b>No need for over-fetching&#58;</b> Continuing the above example, you may decide a workaround is to return details of all orders with all customer queries. However, this overwhelms your client with data it doesn’t need most of the time, just to solve a problem in one scenario. This is called over-fetching (and is the specific problem Facebook set out to resolve with GraphQL).</li></ul><dl class="badImage"><dt><img src="/SiteAssets/graphql-when-to-use/graph-ql-bad-overfetching.png" alt="graph-ql-bad-overfetching.png" style="margin&#58;5px;width&#58;750px;height&#58;511px;" /><br></dt><dd>Figure&#58; Bad Example – REST API returns a whole bunch of data the client doesn’t need – killing bandwidth (and, on mobile, battery)<br></dd></dl><ul><li> 
      <b>Client Defined Queries&#58;</b> In a REST API, the CRUD operations are defined by the API, and the client application is constrained by the operations available. This means that any changes required by your UI necessitate changes to your back end as well. With GraphQL you can change your client queries to meet changing UI needs without needing to update your back end.</li></ul><dl class="goodImage"><dt><img src="/SiteAssets/graphql-when-to-use/graphql-good-example-shaped-query.png" alt="graphql-good-example-shaped-query.png" style="margin&#58;5px;width&#58;750px;height&#58;440px;" /><br></dt><dd>Figure&#58; Good Example – Clients can write queries and specify which fields they want the query to return<br></dd></dl><h3 class="ssw15-rteElement-H3"> Disadvantages of GraphQL</h3>Sounds great, right? Well, there are some limitations to be aware of before you rush to add it to all your solutions.<br><br> 
<ul><li> 
      <b>No caching&#58;</b> With the exception of the POST HTTP verb, REST calls are idempotent. This means that for any REST call, if the parameters are the same, the result&#160;will always be the same. And as REST is built on top of HTTP, and most HTTP stacks have caching built-in, you get client-side caching for free with REST. With GraphQL, this is not possible. If you want to take advantage of caching, it needs to be server-side and requires effort on the part of the developer.<br></li><li> 
      <b>Not suitable for rich content&#58; </b>GraphQL is a query language, and is fundamentally meant for data. Rich content, like images and videos, is not best suited to GraphQL. GraphQL is a text-based specification, and while it is possible to (for example) encode images into Base64 strings and send them as a field in your GraphQL type, this is not the best way to do it. This is analogous to storing BLOBs in your SQL database – you can do it, but it’s not a good idea.</li></ul><dl class="badImage"><dt><img src="/SiteAssets/graphql-when-to-use/graphql-image-base64.png" alt="graphql-image-base64.png" style="margin&#58;5px;width&#58;750px;height&#58;445px;" /><br></dt><dd>Figure&#58; Bad Example – Image encoded as Base64 string uses more bandwidth and processing power than necessary, resulting in poor UX</dd></dl><h3>When to use GraphQL</h3> ​GraphQL is best for when your client needs to display information from multiple sources in one UI. Use GraphQL to service complex queries in your client applications without multiple round-trips to the server.<br><br>GraphQL is not a replacement for REST; in fact, it’s often best to use them together. While GraphQL supports changing state on the server through migrations, the true power of GraphQL is in queries. Many create, update, and delete operations are relatively unchanging and can benefit from being maintained as REST resources – think sign-up forms for example. REST is also better for transferring rich content, like images and videos.
<dl class="goodImage"><dt><img src="/SiteAssets/graphql-when-to-use/good-example-image-url.png" alt="good-example-image-url.png" style="margin&#58;5px;width&#58;750px;height&#58;480px;" /><br></dt><dd>Good Example – GraphQL used to construct a complex query with embedded entities, and images are referenced with a URI that the client can use to retrieve from a REST endpoint</dd></dl><h3 class="ssw15-rteElement-H3">The best GraphQL Resources​​</h3>
   
   <ul><li>​The official GraphQL website is an excellent resource for learning GraphQL. The <a href="https&#58;//graphql.org/learn/">learning section</a>&#160;contains many interactive examples that you can edit as you go.</li><li>There are a few GraphQL libraries for .NET. The best known is <a href="https&#58;//github.com/graphql-dotnet/graphql-dotnet">GraphQL.Net</a>&#160;which has client and server libraries. But the best library for .NET is <a href="https&#58;//github.com/ChilliCream/hotchocolate">Hot Chocolate</a>. Hot Chocolate, and the associated tools and libraries, are all named after desserts, which is bad – see <a href="/_layouts/15/FIXUPREDIRECT.ASPX?WebId=3dfc0e07-e23a-4cbb-aac2-e778b71166a2&amp;TermSetId=07da3ddf-0924-4cd2-a6d4-a4809ae20160&amp;TermId=4be22043-306c-4c6f-b9b6-ec2ff37be97e">https&#58;//rules.ssw.com.au/follow-naming-conventions​</a>, but despite this, these are the best tools for working with GraphQL in .NET.</li><li>There are lots of GraphQL libraries for JavaScript, but <a href="https&#58;//www.apollographql.com/">Apollo</a> is the best one. Apollo is a commercial data platform, with free and paid offerings, but they have free and open source client and server libraries. See&#58; <a href="https&#58;//github.com/apollographql">https&#58;//github.com/apollographql</a>​</li></ul>
   <p></p>


