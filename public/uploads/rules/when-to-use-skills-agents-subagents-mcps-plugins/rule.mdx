---
title: 'Do you know when to use skills, agents, subagents, MCPs?'
uri: when-to-use-skills-agents-subagents-mcps-plugins
categories:
  - category: categories/artificial-intelligence/rules-to-better-ai-assisted-development.mdx
authors:
  - title: Michael Qiu
    url: 'https://ssw.com.au/people/michael-qiu'
  - title: Eddie Kranz
    url: 'https://ssw.com.au/people/eddie-kranz'
  - title: Josh Berman
    url: 'https://ssw.com.au/people/josh-berman'
related:
  - rule: public/uploads/rules/ai-agents-with-skills/rule.mdx
  - rule: public/uploads/rules/mcp-servers-for-context/rule.mdx
  - rule: public/uploads/rules/build-custom-agents/rule.mdx
  - rule: public/uploads/rules/use-mcp-to-standardize-llm-connections/rule.mdx
guid: 8a2a5abd-103a-4f6f-8d0e-80dd596fbbae
seoDescription: 'Learn when to use skills, agents, subagents, MCP servers, or plugins to extend AI coding tools. A decision framework for choosing the right extensibility mechanism.'
created: 2026-02-16T22:31:05.841Z
createdBy: Michael Qiu
createdByEmail: MichaelQiu@ssw.com.au
lastUpdated: 2026-02-18T00:10:29.692Z
lastUpdatedBy: Josh Berman
lastUpdatedByEmail: JoshBerman@ssw.com.au
---

AI coding tools like Claude Code, GitHub Copilot, and OpenCode offer several ways to extend their capabilities - skills, custom agents, subagents, MCP servers, and plugins. Each solves a different problem, and picking the wrong one leads to unnecessary complexity or limitations. Knowing which mechanism to reach for saves time and keeps your setup maintainable.

<endIntro />

## An AI Glossary

### Agent

Agents are what developers interact with, they take the necessary actions to achieve the users intended goal. By utilising the following tools, they can be enhanced for specific scenarios to be even more effective.

<boxEmbed
  body={<>
    Use Case: You need to implement a new feature on your website E2E. A single agent will allow for full context.
  </>}
  figurePrefix="none"
  figure=""
/>

### Subagent

Subagents are isolated AI instances with their own context window, capable of running in parallel with other subagents from a primary agent. This reduces the fluff inside of the main conversation window, with the primary process only receiving summaries of results of the subagents.

<boxEmbed
  body={<>
    **Use Case:** You ask an agent to research five competitors. Instead of going through each competitor sequentially, it can spawn five subagents that each research one in parallel, then the primary agent synthesizes the results into a single comparison. The win is speed and focus.
  </>}
  figurePrefix="none"
  figure=""
  style="greybox"
/>

### AGENTS.md

AGENTS.md is a markdown file that is loaded at the start of every session, providing project context to the AI Agent.

<boxEmbed
  body={<>
    **Use Case:** In a monorepo with React frontend and Python backend. Each directory has an AGENTS.md tells agents the local rules: "use pytest," "all routes need auth middleware." This allows the codebase-specific context to be injected into every conversation, improving consistency by eliminating the need for developers to repeat themselves.
  </>}
  figurePrefix="none"
  figure=""
  style="greybox"
/>

<boxEmbed
  body={<>
    `AGENTS.md` is the cross-platform convention for providing project context to most AI coding tools. However, some tools still use their own file
    
    * Claude Code uses `CLAUDE.md`
    * Cursor uses `.cursorrules`
    
    But the concept remains the same. This rule uses `AGENTS.md` as the general term.
  </>}
  figurePrefix="none"
  figure=""
  style="tips"
/>

### Skill

Skills are reusable prompts that standardize how AI approach repeating tasks. Like AGENTS.md, skills are also markdown files, but their purpose is to be situationally invoked when relevant and be portable across codebases.

<boxEmbed
  body={<>
    **Use Case:** A company has a specific way they like to perform security audits using AI. Rather than copy and pasting the promopt, we install the skill and instruct the agent to perform a security audit using the installed skill. The skill is injected into the agent's context, so the agent receives the same instruction every time.
  </>}
  figurePrefix="none"
  figure=""
  style="greybox"
/>

### MCP Server

[MCP servers](/use-mcp-to-standardize-llm-connections) are an external process that exposes tools and data via the open standard of [Model Context Protocol](https://modelcontextprotocol.io/docs/getting-started/intro), allowing your AI agents to use tools and access external data.

<boxEmbed
  body={<>
    **Use Case:** You want your agent to see if the changes it made are reflected in your SQL database. You install an SQL MCP server to your agent. It is then able to read from the database and inform its context.
  </>}
  figurePrefix="none"
  figure=""
  style="greybox"
/>

## Understanding the differences

With how rapidly AI-assisted development is evolving, we find these tools often overlap one another with the problem they're intended to solve. Here are the key differences between some seemingly similar tools.

### Skills vs MCP Servers

**Similarities:**

* Both are designed to be shared and portable
* Both inject situation-specific context into agents
* Both are automatically invoked by agents based on the situation

**High level difference:**

* Skills tell the agents what to do - they inject prompts, workflows, and domain specific knowledge
* MCP Servers give agents access to the tools - they connect agents to external systems

**Structural difference:**

* Skills are simply markdown files with some frontmatter. This makes them easily shared and lightweight. It's effectively a "portable set of instructions", which is intended to be reused.
* MCP servers are code. They expose tools for agents and the instructions on how to use those tools.

Skills and MCPs are complementary to one another: A skill can instruct the AI to use tools exposed by an MCP server.

<boxEmbed
  body={<>
    **Scenario:** You want your agent to create a GitHub issue with a specific format whenever it finds a bug.
    
    * **Skills** define the issue template and tell it to use the GitHub MCP server, the labeling conventions, and the workflow steps
    * The MCP server provides the connection to the GitHub API so the agent can actually create the issue
  </>}
  figurePrefix="good"
  figure="Skills and MCP servers working together - the skill defines the workflow, the MCP server provides the integration"
  style="greybox"
/>

### Skills vs AGENTS.md

**Similarities:**

* Both provide instructions to agents via prompt injection
* Both are stored within markdown files
* Both influence how the agent behaves on a task

**High level difference:**

* AGENTS.md defines general, always-present rules and conventions for a codebase
* Skills define specific, on-demand instructions for particular tasks that are portable across codebases

**Structural difference:**

* AGENTS.md is always loaded - every token counts against your context window from the start
* Skills load on demand - only the name and description are loaded at startup (\~30-50 tokens each), with full instructions loading only when the skill is relevant

Whilst you can put all your "skills" in AGENTS.md, this introduces unnecessary token waste and can lead to lower quality outputs as bloated AGENTS.md files can sometimes cause agents to ignore some instructions.

<boxEmbed
  body={<>
    **Scenario:** Your team has a standard way of performing code reviews and a set of project conventions.
    
    * **AGENTS.md** defines the project conventions - "use pytest," "all API routes need auth middleware," "follow the repository's folder structure"
    * **Skills** define the code review workflow - the checklist, the format of review comments, and the steps to follow. This only loads when a review is actually requested, keeping context clean for other tasks
  </>}
  figurePrefix="good"
  figure="AGENTS.md for always-on project context, skills for on-demand task-specific workflows"
  style="greybox"
/>

### Subagents vs Skills

**Similarities:**

* Both can be used to achieve similar end results for a given task
* Both extend the capabilities of an agent beyond its defaults
* Both reduce the need for repetitive manual prompting

**High level difference:**

* Skills define **what** the agent should do - they provide instructions and workflows
* Subagents define **how** the agent executes - they provide isolated, parallel execution contexts

**Structural difference:**

* Skills run sequentially within the main agent's context - the agent needs to finish one task before moving onto the next
* Subagents run in their own isolated context windows in parallel - multiple tasks can be processed simultaneously, but they cannot interact with the user mid-execution

Because subagents cannot have back-and-forth interaction with the user, they are best suited for self-contained tasks. Skills, on the other hand, run within the main agent and can still leverage user interaction when needed.

<boxEmbed
  body={<>
    **Scenario:** You want to audit your codebase for security vulnerabilities across 4 microservices.
    
    * **With a skill**, the agent follows the security audit workflow sequentially - auditing one service, reporting findings, then moving to the next. You can give feedback between each service
    * **With subagents**, the agent spawns 4 subagents that each audit one service in parallel, then synthesizes all findings into a single report. Faster, but no mid-process feedback
  </>}
  figurePrefix="good"
  figure="Use skills when you need step-by-step control, use subagents when you need speed and the task is self-contained"
  style="greybox"
/>

### Agents vs Subagents

**Similarities:**

* Both are AI instances that can execute tasks autonomously
* Both have access to tools (file reading, code execution, etc.)
* Both can reason about and act on a given task

**High level difference:**

* Agents are the primary process - they interact directly with the user and orchestrate work
* Subagents are child processes - they are spawned by the primary agent to handle isolated, self-contained tasks

**Structural difference:**

* Agents run in the main context window and can have back-and-forth conversations with the user
* Subagents run in their own isolated context window - heavy search results don't clutter the main conversation, and you can restrict what tools a subagent has access to (e.g. read-only for reviewers). The main conversation only receives a summary of the work done by subagents

You should use subagents when the task is self-contained and does not require user interaction. In tools that don't yet support subagents directly, custom agents with restricted tool access can serve a similar purpose.

<boxEmbed
  body={<>
    **Scenario:** You ask an agent to research five competitors and summarize the findings.
    
    * **Without subagents**, the agent researches each competitor sequentially in the main context window, filling it with raw search results and intermediate notes
    * **With subagents**, the agent spawns five subagents that each research one competitor in parallel. The main agent only receives the summaries and synthesizes a final comparison - keeping the main context clean and completing the task faster
  </>}
  figurePrefix="good"
  figure="Use subagents for self-contained parallel tasks, keeping the main agent's context focused"
  style="greybox"
/>

## The extensibility spectrum

These mechanisms form a spectrum from simple to complex. Start simple and only add complexity when needed:

1. **AGENTS.md** - Static knowledge and conventions (start here)
2. **Skills** - Reusable, on-demand expertise with supporting files
3. **MCP Servers** - External tool and data source integration
4. **Custom agents / Subagents** - Isolated, specialized execution contexts
5. **Agent SDK** - Full programmatic agents for production systems

<boxEmbed
  body={<>
    You can think of it like a software project:
    
    * **AGENTS.md** are your README and .env file - always-present configuration
    * **Skills** are your utility library - reusable, modular, loaded when needed
    * **Subagents** are your worker threads - isolated, parallel, focused execution
    * **MCP Servers** are your API integrations - connecting to external services
  </>}
  figurePrefix="none"
  figure=""
  style="tips"
/>

## Practical adoption strategy

There is no need for stress over selecting the perfect tool every ttime, they're all just optimizations for specific use cases anad do not have drastic consequences for choosing the wrong tool. As you continue to use them, it will become clearer as you do when specific tools make your AI assisted workflow easier.

Don't try to adopt everything at once. Instead, follow this progression to get comfortable with the tools available:

1. **Start with AGENTS.md** - Add your project conventions, build commands, and architecture overview
2. **Create skills for your top 3 repeated tasks** - Code reviews, commit messages, and planning are common first choices
3. **Configure MCP servers for external integrations** - Databases, GitHub, search APIs
4. **Build custom agents for specialized roles** - Read-only reviewers, parallel researchers, implementation planners

## Further reading

* [Do you use skills to standardize your AI workflows?](/rules/ai-agents-with-skills)
* [Do you give your AI agents context with MCP servers and skills?](/rules/mcp-servers-for-context)
* [Do you build custom agents for complex tasks?](/rules/build-custom-agents)
* [Agent Skills open standard](https://agentskills.io)
* [Model Context Protocol](https://modelcontextprotocol.io/introduction)
* [Building Effective Agents - Anthropic](https://www.anthropic.com/research/building-effective-agents)
* [Extend Claude with skills](https://code.claude.com/docs/en/skills)
* [Custom agents - GitHub Copilot](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/create-custom-agents)
* [Agent Skills - OpenCode](https://opencode.ai/docs/skills/)
