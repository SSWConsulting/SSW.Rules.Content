---
type: rule
title: Do you use AI CLI tools?
uri: ai-cli-tools
categories:
  - category: categories/artificial-intelligence/rules-to-better-ai-development.mdx
authors:
  - title: Luke Cook
    url: 'https://www.ssw.com.au/people/luke-cook'
  - title: Daniel Mackay
    url: 'https://www.ssw.com.au/people/daniel-mackay'
  - title: Gordon Beeming
    url: 'https://www.ssw.com.au/people/gordon-beeming'
related: []
guid: e244ecf4-f6cf-4ffc-8a3b-5cdf7bb75a7f
seoDescription: 'Discover why AI-powered CLI tools like GitHub Copilot CLI, OpenCode, and Claude Code can boost productivity and deliver better quality results than IDE extensions.'
created: 2026-01-12T02:42:56.895Z
createdBy: Luke Cook
createdByEmail: LukeCook@ssw.com.au
lastUpdated: 2026-01-14T07:11:57.074Z
lastUpdatedBy: Luke Cook
lastUpdatedByEmail: LukeCook@ssw.com.au
---

AI coding assistants have become essential tools for developers, but many rely solely on IDE extensions like GitHub Copilot or Cursor. While these are valuable, **AI CLI tools** offer unique advantages that can significantly boost your productivity and code quality.

CLI-based AI tools provide a focused, distraction-free environment with full terminal context, making them ideal for complex tasks, debugging, and working with entire codebases.

Anecdotally, developers have noticed that CLI tools often produce higher-quality, more accurate results than their IDE counterparts - possibly due to better context handling and fewer UI constraints.

<endIntro />

<youtubeEmbed url="https://youtu.be/MsQACpcuTkU" description="Video: You've Been Using AI the Hard Way (Use This Instead) (33 min)" />

## Why use AI CLI tools?

### ✅ Benefits

* **Better context awareness** - CLI tools can access your entire terminal history, file system, and git state, providing richer context for better suggestions
* **Higher quality output** - SSW developers have observed that CLI tools consistently produce more accurate and contextually appropriate code than IDE extensions
* **Better for complex tasks** - Debugging, refactoring, and multi-file operations often work better in the CLI
* **Universal workflow** - Works across any editor or environment (Vim, VS Code, Notepad++, etc.)
* **Git integration** - Natural integration with git commands and workflows
* **Batch operations** - Easier to automate and script repetitive tasks

### ❌ Trade-offs

* **Learning curve** - Requires comfort with command-line interfaces
* **No inline suggestions** - Unlike IDE extensions, you won't get suggestions as you type
* **Context switching** - Moving between your editor and terminal requires discipline
* **Setup overhead** - May require additional configuration compared to IDE plugins
* **Less visual** - No syntax highlighting or preview in suggestions (though output can be piped to editors)

## Popular AI CLI tools

### 1. GitHub Copilot CLI

GitHub's official command-line tool for AI-assisted development. Unsurprisingly, Copilot CLI provides first-class integration with GitHub.

**✅ Pros:**

* **⭐️ Delegation** - One standout feature not available with other CLI tools is the `/delegate` command which pushes your existing local session to a GitHub coding agent (with context!)
* **Custom agents** - You can define custom agents via markdown files with options to define agents at user, repository, and org level within GitHub

**❌ Cons:**

* **Flexibility** - Copilot CLI locks you into one provider: Copilot. If you're all in on Team GitHub, this is fine. But if you're looking for more options and
  less vendor lock-in, you're better off with something like OpenCode

**Learn more:** [GitHub Copilot CLI Documentation](https://docs.github.com/en/copilot/concepts/agents/about-copilot-cli)

<boxEmbed
  body={<>
    #### Bonus: Sandboxed Copilot CLI
    
    One of SSW's Solution Architects has created a sandboxed version of Copilot CLI, **[Copilot Here](https://github.com/gordonbeeming/copilot_here)**. If you're working
    in a high-sec environment or just want added protection around what AI can and cannot access during sessions, we highly recommend checking this out. It spins up within Docker,
    is wired to its own reverse-proxy, and provides external controls around the agent itself.
  </>}
  figurePrefix="none"
  figure=""
  style="tips"
/>

### 2. OpenCode

OpenCode is an **open-source** agent that gives you the most options when it comes to models, providers, and extensibility. While it does provide some free models
OOTB, you are expected to BYO model subscription.

**✅ Pros:**

* **⭐️ Flexibility** - OpenCode allows you to select from almost any model, as well as select your own **provider**. This kind of agnosticism is a huge win for users,
  especially with the AI landscape being as volatile as it is. Being able to learn one CLI, define your own custom agents within it, and then and the models and providers
  arbitrarily is a godsend
* **Custom agents** - Custom agents are again defined by markdown files, and while they can be defined and used at a repository level, the general principle of OpenCode is for agents to be user-level definitions
* **Subagent usage** - OpenCode is better at reasoning about subagent usage automatically, rather than needing to be explicitly directed to do so. On a long enough agent session, context compacting is a real problem and can degrade the quality of output, so having enthusiastic subagent usage is a big plus

**❌ Cons:**

* **Integration** - Being an independent open-source agent, OOTB integration may not be as robust (or available as quickly) as proprietary tools like Copilot CLI.

**Learn more:** [OpenCode GitHub Repository](https://github.com/anomalyco/opencode)

### 3. Claude Code (via Anthropic CLI)

Claude Code is another fan favourite at SSW.

**✅ Pros:**

* **⭐️ Custom agents** - Claude Code's custom agents are the most configurable we've used. While they provide all the functionality of other offerings (e.g. personas, allowed tools/paths, etc.), Claude's custom agents also provide dedicated pre and post-use hooks. This is excellent to help with deterministic tool execution, allowing you to guarantee that certain scripts or commands will be run before and after the agent
* ✅ Integration - Claude has some interesting integrations that aren't available with other tools OOTB, such as Slack integration

**❌ Cons:**

* **Flexibility** - Similar to GitHub Copilot, Claude Code locks you in to one provider (but there are ways around this, like [https://claudish.com/](https://claudish.com/))

**Learn more:** [Anthropic CLI Documentation](https://github.com/anthropics/anthropic-cli)

### 4. Other notable tools

* **[Warp AI](https://www.warp.dev/)** - Built into Warp terminal for command suggestions
* **[Fig AI](https://hellofig.io/)** - Autocomplete with AI explanations (acquired by AWS)
* **[Shell GPT](https://github.com/TheR1D/shell_gpt)** - Simple GPT integration for shell commands
* **[Codex](https://openai.com/codex/)** - OpenAI's open source CLI tool
* [Gemini CLI ](https://geminicli.com/)- Google's offering, has a very generous free tier

## When to use IDE vs CLI

### ✅ Good use cases for **CLI tools**

* Complex debugging sessions
* Multi-file refactoring
* Git operations and history analysis
* Learning new commands or APIs
* Automation and scripting
* Working across different editors
* Deep code analysis requiring full project context

### ✅ Good use cases for **IDE tools**

* Real-time code completion while typing
* Quick inline suggestions
* Single-file editing
* Learning and exploration
* When you need visual feedback immediately

<boxEmbed
  body={<>
    **Pro tip:** You should be using both!
    
    IDE extensions for real-time suggestions while coding, and CLI tools for complex problem-solving, debugging, and refactoring tasks.
  </>}
  figurePrefix="none"
  figure=""
  style="info"
/>

## Getting started

1. **Choose a tool** - Start with GitHub Copilot CLI if you already have a Copilot subscription, or try OpenCode for an open-source option
2. **Install and configure** - Follow the installation instructions for your chosen tool
3. **Start small** - Begin with simple queries like explaining commands or generating shell scripts
4. **Integrate into workflow** - Gradually incorporate CLI AI into your debugging and refactoring workflows
5. **Experiment** - Try different tools to find what works best for your workflow

## Best practices

* **Provide context** - The more information you give (file paths, error messages, what you've tried), the better the results
* **Iterate** - CLI tools work best in a conversational workflow—refine your prompts based on responses
* **Review output** - Always review and understand generated code before using it
* **Combine with version control** - Use git to track AI-generated changes and easily revert if needed
* **Use for learning** - Ask CLI tools to explain their suggestions to deepen your understanding
* **Subagent switching** - Get comfortable with switching between specific subagents like `Plan` and `Build`

By incorporating AI CLI tools into your workflow alongside IDE extensions, you can leverage the strengths of both approaches for maximum productivity and code quality.
