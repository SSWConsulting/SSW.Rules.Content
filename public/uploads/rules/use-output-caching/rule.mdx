---
type: rule
title: Do you use Output Caching for better API performance?
uri: use-output-caching
authors:
  - title: Hajir Lesani
    url: https://www.ssw.com.au/people/hajir-lesani
categories:
  - category: categories/software-engineering/rules-to-better-web-api-rest.mdx
guid: 8f2a1b3c-4d5e-6f7a-8b9c-0d1e2f3a4b5c
seoDescription: Learn how to use ASP.NET Core Output Caching middleware for better API performance, including cache policies, tag invalidation, and when to choose output caching over response caching.
created: 2026-02-05T00:00:00.000Z
---

When your API serves the same data repeatedly, every request hits your database and business logic unnecessarily. Output Caching stores the complete HTTP response and serves it directly for subsequent requests, dramatically improving performance and reducing server load.

ASP.NET Core 7+ includes built-in Output Caching middleware that's more powerful and flexible than the older Response Caching.

<endIntro _hidden="" />

## Output Caching vs Response Caching

| Feature | Output Caching | Response Caching |
|---------|---------------|------------------|
| Cache location | Server-side | Client/proxy (HTTP headers) |
| Control | Full programmatic control | Depends on client behavior |
| Invalidation | Tag-based, programmatic | Time-based only |
| Cache storage | Memory, Redis, custom | N/A (client-side) |

## Setting up Output Caching

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddOutputCache(options =>
{
    // Default policy - cache for 60 seconds
    options.AddBasePolicy(builder => builder.Expire(TimeSpan.FromSeconds(60)));

    // Named policy for specific endpoints
    options.AddPolicy("CacheProducts", builder =>
        builder.Expire(TimeSpan.FromMinutes(10))
               .Tag("products"));
});

var app = builder.Build();
app.UseOutputCache();
```

**✅ Figure: Good example - Configure output caching with default and named policies**

## Applying cache policies to endpoints

```csharp
// Without caching - hits database every time
app.MapGet("/api/products", async (ProductDbContext db) =>
{
    return await db.Products.ToListAsync();
});
```

**❌ Figure: Bad example - No caching means unnecessary database hits for unchanged data**

```csharp
// With output caching - serves cached response
app.MapGet("/api/products", async (ProductDbContext db) =>
{
    return await db.Products.ToListAsync();
})
.CacheOutput("CacheProducts");

// Or inline policy
app.MapGet("/api/categories", async (ProductDbContext db) =>
{
    return await db.Categories.ToListAsync();
})
.CacheOutput(policy => policy.Expire(TimeSpan.FromMinutes(5)));
```

**✅ Figure: Good example - Cache responses to reduce database load**

## Cache invalidation with tags

The real power of Output Caching is tag-based invalidation - when data changes, invalidate only the relevant cached responses.

```csharp
app.MapPost("/api/products", async (
    Product product,
    ProductDbContext db,
    IOutputCacheStore cache) =>
{
    db.Products.Add(product);
    await db.SaveChangesAsync();

    // Invalidate all responses tagged with "products"
    await cache.EvictByTagAsync("products", default);

    return Results.Created($"/api/products/{product.Id}", product);
});
```

**✅ Figure: Good example - Invalidate cache when data changes using tags**

## When to use Output Caching

**Use Output Caching when:**

* Data changes infrequently (product catalogs, reference data)
* Multiple users request the same data
* You need server-side control over caching
* You want tag-based invalidation

**Don't use Output Caching when:**

* Responses are user-specific (use Response Caching with Vary headers instead)
* Data is highly dynamic (real-time dashboards)
* Responses contain sensitive data
* You need distributed caching across multiple servers (use Redis-backed output cache)

## Distributed Output Caching with Redis

For multi-server deployments, use Redis as the cache store:

```csharp
builder.Services.AddStackExchangeRedisOutputCache(options =>
{
    options.Configuration = builder.Configuration.GetConnectionString("Redis");
    options.InstanceName = "MyApp:";
});
```

**✅ Figure: Good example - Use Redis for output caching in distributed environments**
