---
type: rule
title: Do you know how to multi-target your .NET projects?
uri: manage-compatibility-for-different-tfms
categories:
  - category: categories/software-engineering/rules-to-better-net10-migrations.mdx
authors:
  - title: Yazhi Chen
    url: 'https://www.ssw.com.au/people/yazhi-chen'
  - title: Kaha Mason
    url: 'https://ssw.com.au/people/kaha-mason'
guid: 05a2bdf2-d173-4c46-a700-b2b3b83408e2
seoDescription: 'Learn how to manage compatibility between different Target Frameworks by using multi-targeting, C# preprocessor directives, and MSBuild conditions.'
created: 2023-09-01T01:39:10.755Z
createdBy: Kaha Mason
createdByEmail: kahamason@ssw.com.au
lastUpdated: 2026-02-04T05:59:35.203Z
lastUpdatedBy: Kaha Mason
lastUpdatedByEmail: kahamason@ssw.com.au
---

Migrating your project to the latest version of .NET can be a difficult task, especially when you need to maintain compatibility with older versions of .NET during the transition. Ultimately, we want to get our projects to be running on the newest and latest .NET, but this process often requires careful planning and execution so as to not impact our existing application.

Multi-targeting target framework allows you to build and test your project against multiple versions of .NET simultaneously, which can help you maintain your current application while progressively migrating to the latest .NET version. This will also allow you to identify and resolve compatibility issues early in the migration process, which will save time and effort overall.

This rule provides guidance on how to manage compatibility when transitioning between target frameworks.

<endIntro />

Here are some strategies to help you manage compatibility between different frameworks:

### Multi-targeting your project

You can specify multiple target frameworks in your project file using the `TargetFrameworks` property:

```xml
<PropertyGroup>
  <TargetFrameworks>net48;net10.0</TargetFrameworks>
</PropertyGroup>
```

This approach lets you continue to maintain your current application while also building and testing for the desired target framework you aim to migrate to. Being able to build and test against both target frameworks makes compatibility issues more visible in CI (because both target frameworks will compiled).

One big downside of this approach is that it increases build and test times, since each target framework will be built and tested separately. This can essentially multiply the build / test times by a multitude of each target framework specified in the project. 

This is a temporary overhead during migration and will be fixed once the full migration is complete and you can remove the old target framework from `TargetFrameworks`.

### Using C# preprocessor directives (`#if`, `#elif`, `#endif`)

You can use C# preprocessor directives to compile code exclusively for a specific target framework. This technique also simplifies the removal process during post-migration cleanup, especially for incompatible code segments.
Whenever possible, consider using dependency injection or factory patterns to inject the appropriate implementation based on the target framework you are targeting. This approach promotes code flexibility and maintainability, as it abstracts away target framework-specific details.

```cs
public static class WebClientFactory
{
  public static IWebClient GetWebClient()
  {
#if NET48
    return new CustomWebClient();
#else
    return new CustomHttpClient();
#endif
  }
}
```
**✅ Code: Good example - Using preprocessor directives and a factory pattern**

Tip: Prefer explicit version checks when possible, as they scale better than `#else`:

```cs
#if NET
// Use the modern .NET implementation
#else
// Use the .NET Framework implementation
#endif
```

If you want `#if NET48` to work reliably, define it in your project file (so it’s available when compiling the `net48` target):

```xml
<PropertyGroup Condition="'$(TargetFramework)' == 'net48'">
  <DefineConstants>$(DefineConstants);NET48</DefineConstants>
</PropertyGroup>
```
**✅ Code: Good example - Defining custom preprocessor symbols per target framework**

### Using MSBuild conditions

You can use MSBuild conditions to add references to different libraries that are only compatible with a specific target framework. This enables you to manage references dynamically based on the target framework in use.
```xml
<ItemGroup Condition="'$(TargetFramework)' == 'net48'">
    <Reference Include="System.Web" />
    <Reference Include="System.Web.Extensions" />
    <Reference Include="System.Web.ApplicationServices" />
</ItemGroup>
```
**✅ Code: Good example - Using MSBuild conditions**

#### Conditional NuGet packages per target framework

In SDK-style projects, you can use a similar approach to separate target-specific NuGet packages:

```xml
<ItemGroup Condition="'$(TargetFramework)' == 'net48'">
  <PackageReference Include="Some.Legacy.Package" Version="1.*" />
</ItemGroup>

<ItemGroup Condition="'$(TargetFramework)' == 'net10.0'">
  <PackageReference Include="Some.Modern.Package" Version="10.*" />
</ItemGroup>

<ItemGroup>
  <PackageReference Include="Common.Package" Version="5.*" />
</ItemGroup>
```
**✅ Code: Good example - Conditional NuGet packages per target framework**

#### Optional: Include different source files per target framework

If the implementation differs a lot, keep the code in separate files and include them conditionally:

```xml
<ItemGroup Condition="'$(TargetFramework)' == 'net48'">
  <Compile Include="Compatibility\\WebClientFactory.net48.cs" />
</ItemGroup>

<ItemGroup Condition="'$(TargetFramework)' == 'net10.0'">
  <Compile Include="Compatibility\\WebClientFactory.net10.cs" />
</ItemGroup>
```
**✅ Code: Good example - Conditional source files per target framework**

### Post-migration cleanup

Once the main branch has fully moved to the new target framework:
* Remove the old target framework from `TargetFrameworks`
* Delete the old implementation paths (or per-target framework files)
* Remove conditional MSBuild blocks and legacy package references

### Definition of done

* The project builds for all target frameworks
* Tests run for each target framework in CI
* Compatibility code is isolated (minimal `#if` in domain/business logic)
