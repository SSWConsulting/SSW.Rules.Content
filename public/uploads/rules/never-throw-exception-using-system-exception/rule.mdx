---
archivedreason: null
authors:
- title: Adam Cogan
  url: https://ssw.com.au/people/adam-cogan
- title: Matt Wicks
  url: https://www.ssw.com.au/people/matt-wicks
- title: Piers Sinclair
  url: https://www.ssw.com.au/people/piers-sinclair
categories:
- category: categories/software-engineering/rules-for-error-handling.mdx
created: 2024-06-14 01:52:08+00:00
createdBy: Brady Stroud [SSW]
createdByEmail: bradystroud@ssw.com.au
guid: d1c0e7ba-09e6-4b89-b2d5-695e47e18064
isArchived: false
lastUpdated: 2024-09-25 04:34:30+00:00
lastUpdatedBy: Brook Jeynes [SSW]
lastUpdatedByEmail: brookjeynes@ssw.com.au
redirects:
- do-you-know-that-you-should-never-throw-an-exception-using-system-exception
seoDescription: Do not throw exceptions using System.Exception to avoid generic exception
  handling and instead use specific exception classes that clearly convey the error's
  meaning.
title: Do you know that you should never throw an exception using System.Exception?
type: rule
uri: never-throw-exception-using-system-exception
---

While everyone knows that `catch (Exception ex)` is bad, no one has really noticed that `throw new Exception()` is worse.

`System.Exception` is a very extensive class, and it is inherited by all other exception classes. If you throw an exception with the code `throw new Exception()`, what you need subsequently to handle the exception will be the infamous `catch (Exception ex)`.

<endOfIntro />

As a standard, you should use an exception class with the name that best describes the exception's detail. All exception classes in .NET Framework follow this standard very well. As a result, when you see exceptions like FileNotFoundException or DivideByZeroException, you know what's happening just by looking at the exception's name. The .NET Framework has provided us a comprehensive list of exception classes that we can use. If you really can't find one that is suitable for the situation, then create your own exception class with the name that best describes the exception (e.g.: EmployeeListNotFoundException).

Also, System.ApplicationException should be avoided as well unless it's an exception related to the application. While it's acceptable and should be used in certain cases, be aware that using it broadly will be just as bad as 'throw new Exception()'.

```cs

public async Task<Unit> Handle(UpdateTodoListCommand request, CancellationToken cancellationToken)
{
        var entity = await _context.TodoLists.FindAsync(request.Id);

        if (entity == null)
        {
                throw new Exception($"Couldn't find a todo list with id: {request.Id}");
        }

        ...
}
```
<figureEmbed figureEmbed={ {
  preset: "badExample",
  figure: "Figure: Bad example - System.Exception is thrown, you now need to read the code to try to work out what is going wrong (hard if it was thrown by code outside of this solution)",
  shouldDisplay: true
} } />


```cs

public async Task<Unit> Handle(UpdateTodoListCommand request, CancellationToken cancellationToken)
{
        var entity = await _context.TodoLists.FindAsync(request.Id);

        if (entity == null)
        {
                throw new NotFoundException(nameof(TodoList), request.Id);
        }

        ...
}
...
public class NotFoundException : Exception
{
        public NotFoundException()
            : base()
        {
        }

        public NotFoundException(string message)
            : base(message)
        {
        }

        public NotFoundException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        public NotFoundException(string name, object key)
            : base($"Entity \"{name}\" ({key}) was not found.")
        {
        }
    }
```
<figureEmbed figureEmbed={ {
  preset: "goodExample",
  figure: "Figure: Good example - A specific exception is thrown which you can specifically catch, the message is consistently formatted and a consuming application can understand what was wrong with their request easily",
  shouldDisplay: true
} } />