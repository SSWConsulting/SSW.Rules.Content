---
authors:
- title: Nick Curran
  url: https://ssw.com.au/people/nick-curran
- title: Kosta Madorsky
  url: https://ssw.com.au/people/kosta-madorsky
- title: Kaha Mason
  url: https://ssw.com.au/people/kaha-mason
- title: Sylvia Huang
  url: https://ssw.com.au/people/sylvia-huang
created: 2023-07-31 22:49:30.966000+00:00
guid: d7ecd82c-da04-4f8e-bf79-9bb6002769e9
related:
- rule: public/uploads/rules/store-your-secrets-securely/rule.mdx
seoDescription: Migrate Web.config settings to ASP.NET Core with ease. Learn how to
  transition appSettings, connection strings, and custom configurations to modern
  JSON files like appsettings.json while leveraging IConfiguration for seamless integration.
title: Do you know how to migrate Web.config to ASP.NET Core?
categories:
  - category: categories/software-engineering/rules-to-better-net10-migrations.mdx
type: rule
uri: know-how-to-migrate-web-config-to-asp-net-core
---

The [`Web.Config`](https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/aspnet/health-diagnostic-performance/create-web-config?WT.mc_id=DT-MVP-33518) file was used in ASP.NET to control the behaviour of individual ASP.NET applications and configure IIS. By default, modern ASP.NET Core applications use the Kestrel web server which is [configured in code](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel/options?view=aspnetcore-10.0&WT.mc_id=DT-MVP-33518).

If you are hosting on IIS, ASP.NET Core still uses a minimal `web.config` (for the ASP.NET Core Module), but you typically do not "migrate" the old `system.web` configuration; you move app/server settings to ASP.NET Core configuration + middleware, and keep only the required IIS integration settings.

The `Web.Config` file contains data about the package inclusions, module inclusions and configuration values.

<endIntro />

## **Understand configuration sources and precedence**

When moving settings out of `Web.config`, it helps to understand how ASP.NET Core loads configuration by default (and which source "wins"). Microsoft Learn documents the default providers and their precedence (for example: `appsettings.json`, `appsettings.{Environment}.json`, user secrets in Development, environment variables, then command-line arguments).

See: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-10.0

Also note that environment variables use `__` (double underscore) to represent `:` in hierarchical keys across platforms.

## Package Inclusions

In ASP.NET Core, project inclusions are listed in the project's CSPROJ file. The dependencies of your application will need to be reviewed as to whether they are still required, and should be added as required using the NuGet Package Manager.

## Server Configuration

The server's configuration needs to be transferred to code within the `Program.cs` file.

### **Minimal `web.config` on IIS (and what not to migrate)**

When hosting ASP.NET Core on IIS, a `web.config` file is still used, but it is typically a minimal file for the **ASP.NET Core Module** (ANCM) and is normally generated during publish.

What usually *doesn't* migrate:

* `<system.web>` settings (classic ASP.NET pipeline configuration). ASP.NET Core does not run on `System.Web`, so these settings need to be replaced with configuration providers + middleware.

What might remain in IIS:

* `system.webServer` settings that are explicitly IIS concerns (for example, IIS-level rewrite rules, static content MIME types, or reverse-proxy behavior that must happen *before* the app runs).

For guidance on IIS hosting and the ASP.NET Core Module, see: https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/?view=aspnetcore-10.0

```xml
<configuration>
  <system.webServer>
    <aspNetCore processPath="dotnet" arguments="MyApp.dll" hostingModel="OutOfProcess" />
  </system.webServer>
</configuration>
```

**Figure: Minimal `web.config` shape for the ASP.NET Core Module (publish typically generates this)**

### Custom Error Pages

The `<customErrors>` element within `<system.web>` specifies redirects for the server to use if a response with a HTTP error code is generated. When the relevant [SSW Rule on useful error pages](/404-useful-error-page/) is followed, the mode will be 'RemoteOnly', meaning that the redirect will only be used if accessed from a separate host. The `<customErrors>` element will provide a default redirect, and may contain `<error>` elements that provide more specific redirects for specific error codes.

The easiest way to transcode this configuration is using [`UseStatusCodePagesWithRedirects`](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-10.0#usestatuscodepageswithredirects&WT.mc_id=DT-MVP-33518) (and typically [`UseExceptionHandler`](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-10.0#exception-handler-page) for unhandled 500 errors).

```xml
<customErrors mode="RemoteOnly" defaultRedirect="~/Error">
    <error statusCode="403" redirect="~/Error?code=403" />
    <error statusCode="404" redirect="~/Error?code=404" />
</customErrors>
```

**Figure: Typical example of custom error redirection**

```cs
var app = builder.Build();
app.UseStatusCodePagesWithRedirects("/Error?code={0}");
```

Figure: The migrated configuration to ASP.NET Core

### Namespaces

The `<pages>/<namespaces>` element defines import directives to use during compilation. The same effect can be achieved using modern C# [implicit import functionality](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives?WT.mc_id=DT-MVP-33518).

### HTTP Handler Routes

The [`<httpHandlers>`](https://learn.microsoft.com/en-us/previous-versions/aspnet/bb398986(v=vs.100)) element links routes to [`IHttpHandler`](https://learn.microsoft.com/en-us/dotnet/api/system.web.ihttphandler?view=netframework-4.8.1&WT.mc_id=DT-MVP-33518) implementations. See the [ASP.NET Core Fundamentals article on Routing](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-10.0&WT.mc_id=DT-MVP-33518) for replacement options, including the use of [`MapGet`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions.mapget?view=aspnetcore-10.0&WT.mc_id=DT-MVP-33518) and [`MapPost`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions.mappost?view=aspnetcore-10.0&WT.mc_id=DT-MVP-33518).

### HTTP Modules

The [`<httpModules>`](https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/aspnet/development/http-modules-handlers) element configures modules that register themselves with the [`HttpApplication`](https://learn.microsoft.com/en-us/dotnet/api/system.web.httpapplication?view=netframework-4.8.1&WT.mc_id=DT-MVP-33518). See the documentation of individual modules regarding how their modern equivalents are to be used with an ASP.NET Core application.

### URL Rewrite rules

The `<rewrite>` element under `<system.webServer>` is often used for redirects, URL rewriting, and SPA fallbacks.

In ASP.NET Core, prefer implementing these behaviors in the app so they work consistently across hosting (Kestrel, IIS, containers). Use the [URL Rewriting middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/url-rewriting?view=aspnetcore-10.0&WT.mc_id=DT-MVP-33518) for rewrite/redirect rules and use middleware like `UseHttpsRedirection()` for HTTPS.

```xml
<system.webServer>
  <rewrite>
    <rules>
      <rule name="Redirect to HTTPS" stopProcessing="true">
        <match url="(.*)" />
        <conditions>
          <add input="{HTTPS}" pattern="off" ignoreCase="true" />
        </conditions>
        <action type="Redirect" url="https://{HTTP_HOST}/{R:1}" redirectType="Permanent" />
      </rule>
    </rules>
  </rewrite>
</system.webServer>
```

**Figure: Typical HTTPS redirect rule in Web.config**

```cs
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseHttpsRedirection();

app.Run();
```

**Figure: The equivalent HTTPS redirect in ASP.NET Core**

If the rewrite logic must live at the IIS layer (e.g., a reverse-proxy rule that should apply before the app runs), keep it in IIS configuration. Otherwise, treat rewrite rules in `Web.config` as application behavior that should move to middleware.

### Static file MIME types

`Web.config` commonly sets custom MIME types under `<staticContent>` (for non-standard file extensions). In ASP.NET Core, configure static files with a `FileExtensionContentTypeProvider`.

```xml
<system.webServer>
  <staticContent>
    <mimeMap fileExtension=".appinstaller" mimeType="application/appinstaller" />
    <mimeMap fileExtension=".msix" mimeType="application/msix" />
  </staticContent>
</system.webServer>
```

**Figure: Custom static content MIME types in Web.config**

```cs
using Microsoft.AspNetCore.StaticFiles;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var contentTypeProvider = new FileExtensionContentTypeProvider();
contentTypeProvider.Mappings[".appinstaller"] = "application/appinstaller";
contentTypeProvider.Mappings[".msix"] = "application/msix";

app.UseStaticFiles(new StaticFileOptions
{
    ContentTypeProvider = contentTypeProvider
});

app.Run();
```

**Figure: The equivalent custom MIME type mapping in ASP.NET Core**

## Custom Configuration Values

Custom configuration values for the application are stored in the `<appSettings>` element. Where configuration values will be moved will depend on whether they should be secret or not.

In the case of non-secret values, they can be moved to an `appsettings.json` file.

```xml
<appSettings>
    <add key="DefaultVisibility" value="public" />
    <add key="DefaultClientCount" value="30" />
</appSettings>
```

**Figure: Typical example of application settings in Web.config**

```json
{
  "DefaultVisibility": "public",
  "DefaultClientCount": 30
}
```

**Figure: The application settings example migrated to `appsettings.json`**

The class used to access configuration values will also need to be changed if the program is using [System.Configuration.ConfigurationManager](https://learn.microsoft.com/en-us/dotnet/api/system.configuration.configurationmanager?WT.mc_id=DT-MVP-33518), as that API is not the modern configuration approach in ASP.NET Core. Instead, use a dependency injected [`IConfiguration`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=dotnet-plat-ext-10.0&WT.mc_id=DT-MVP-33518) implementation from the `Microsoft.Extensions.Configuration` package.

```cs
string visibility = ConfigurationManager.AppSettings["DefaultVisibility"];
int clientCount = int.Parse(ConfigurationManager.AppSettings["DefaultClientCount"]);
// Perform action with configuration values.
```

**Figure: A typical example of using ConfigurationManager to retrieve settings**

```cs
public class TestService
{
    private readonly IConfiguration Configuration;

    public TestService(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public void Act() {
        var visibility = Configuration.GetValue<string>("DefaultVisibility");
      var clientCount = Configuration.GetValue<int>("DefaultClientCount");
        // Perform action with configuration values.
    }
}
```

**Figure: The example code migrated to ASP.NET Core**

## Connection Strings

Connection strings are stored in the `<connectionStrings>` element, and may be directly transferred to the `appsettings.json` file so long as they do not contain any secrets.

```xml
<connectionStrings>
    <add name="DefaultConnection"
         providerName="System.Data.SqlClient"
         connectionString="Server=localhost,1200" />
</connectionStrings>
```

**Figure: A typical example Connection string in Web.config**

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost,1200"
  }
}
```

**Figure: The connection string example migrated to ASP.NET Core**

As discussed above, the `ConfigurationManager` class is no longer available and its usages need to be replaced with calls using `IConfiguration`.

```cs
var connStr = ConfigurationManager.ConnectionStrings["DefaultConnection"]
                                  .ConnectionString;
```

**Figure: A typical example of how to access a Connection string from Web.config**

```cs
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
var connStr = app.Configuration.GetConnectionString("DefaultConnection");
```

**Figure: The example migrated to accessing a connection string within `Program.cs`**

If there are secrets in the connection string, then it should be stored using the secrets manager as per [storing secrets securely](/store-your-secrets-securely). Connection strings have a "ConnectionStrings:" prefix, as demonstrated below. The value is accessible through `IConfiguration` as demonstrated above.

```powershell
dotnet user-secrets set ConnectionStrings:DefaultConnection "Server=localhost,1200"
```

**Figure: Command to set the connection string for local development within the project**