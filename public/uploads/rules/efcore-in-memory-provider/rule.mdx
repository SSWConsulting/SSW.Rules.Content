---
seoDescription: Simplify your Entity Framework Core tests by leveraging the EF Core In-Memory provider, which eliminates database dependencies and improves test reliability.
type: rule
title: Do you use the EF Core In-Memory provider to simplify your tests?
uri: efcore-in-memory-provider
authors:
  - title: Daniel Mackay
    url: https://www.ssw.com.au/people/daniel-mackay/
  - title: William Liebenberg
    url: https://www.ssw.com.au/people/william-liebenberg/
  - title: Jack Pettit
    url: https://www.ssw.com.au/people/jack-pettit/
created: 2023-12-01T07:15:12.000Z
guid: 4e4a6ba5-9ddc-48c3-a7bd-ff3f83a710b7
lastUpdated: 2024-06-08T03:27:17.000Z
lastUpdatedBy: Brady Stroud [SSW]
lastUpdatedByEmail: bradystroud@ssw.com.au
createdBy: Jack Pettit [SSW]
createdByEmail: 57518417+JackDevAU@users.noreply.github.com
isArchived: false
---

<introEmbed
  body={<>
When testing code that depends on Entity Framework Core, the challenge often lies in how to effectively mock out the database access. This is crucial for focusing tests on the functionality surrounding the DB access rather than the database interactions themselves. The EF Core In-Memory provider is a tool designed to address this need.
  </>}
/>
### Common Pitfalls in Mocking

#### Trying to Mock `DbContext`

Attempting to mock the entire `DbContext` is a common mistake. This approach typically leads to complex and fragile test setups, making the tests hard to understand and maintain.
<figureEmbed figureEmbed={ {
  preset: "badExample",
  figure: "```csharp\nvar mockContext = new Mock<ApplicationDbContext>();\n// Adding further mock setups...\n```",
  shouldDisplay: true
} } />


**Figure: Bad Example - Mocking the entire DbContext is overly complex and error-prone.**

#### Trying to Mock `DbSet`

Similarly, mocking `DbSet` entities often results in tests that don't accurately reflect the behavior of the database, leading to unreliable test outcomes.
<figureEmbed figureEmbed={ {
  preset: "badExample",
  figure: "```csharp\nvar mockSet = new Mock<DbSet<MyEntity>>();\n// Configuring mockSet behaviors...\n```",
  shouldDisplay: true
} } />


**Figure: Bad Example - Mocking DbSet entities fails to mimic real database interactions effectively.**

### Good Practice: Using DbContext with In-Memory Provider

Instead of extensive mocking, using `DbContext` with the EF Core In-Memory provider simplifies the setup and reduces the need for mocks. This approach enables more realistic testing of database interactions.
<figureEmbed figureEmbed={ {
  preset: "goodExample",
  figure: "```csharp\nvar options = new DbContextOptionsBuilder<ApplicationDbContext>()\n    .UseInMemoryDatabase(Guid.NewGuid().ToString())\n    .Options;\n\nvar dbContext = new ApplicationDbContext(options);\n\n```",
  shouldDisplay: true
} } />


**Figure: Good Example - Using DbContext with an EF Core In-Memory provider for simpler and more effective testing.**

### Caveat: Limitations of In-Memory Testing

While the EF Core In-Memory provider is useful for isolating unit tests, it's important to recognize its limitations:

- **Behavioral Differences:** It doesn't emulate all aspects of a SQL Server provider, such as certain constraints or transaction behaviors.
- **Not Suitable for Query-focused Tests:** For tests that focus on EF queries, more realistic results can be achieved through integration tests with an actual database.


<asideEmbed
  variant="info"
  body={<>
    Checkout [JK's EF Core Testing Repository](https://github.com/jernejk/MixedEFCoreUnitTesting) for comprehensive examples and advanced scenarios in EF Core testing.
  </>}
  figureEmbed={{
    preset: "default",
    figure: "XXX",
    shouldDisplay: false
  }}
/>
