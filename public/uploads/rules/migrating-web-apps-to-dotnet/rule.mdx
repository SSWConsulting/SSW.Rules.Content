---
type: rule
title: Do you know how to migrate Web Apps to .NET?
uri: migrating-web-apps-to-dotnet
categories:
  - category: categories/software-engineering/rules-to-better-net8-migrations.mdx
authors:
  - title: Luke Cook
    url: 'https://ssw.com.au/people/luke-cook'
  - title: Gordon Beeming
    url: 'https://www.ssw.com.au/people/gordon-beeming'
  - title: Yazhi Chen
    url: 'https://www.ssw.com.au/people/yazhi-chen'
  - title: Thomas Iwainski
    url: 'https://www.ssw.com.au/people/thomas-iwainski'
  - title: Jernej Kavka
    url: 'https://www.ssw.com.au/people/jernej-kavka'
  - title: Sylvia Huang
    url: 'https://www.ssw.com.au/people/sylvia-huang/'
related:
  - rule: public/uploads/rules/dotnet-upgrade-assistant/rule.mdx
  - rule: >-
      public/uploads/rules/migrate-from-system-web-to-modern-alternatives/rule.mdx
  - rule: public/uploads/rules/migration-plans/rule.mdx
  - rule: public/uploads/rules/modernize-your-app/rule.mdx
redirects:
  - migrating-web-apps
guid: 75d6efc2-a8b8-4e0d-8310-ffa076c2bd27
seoDescription: >-
  Migrating web apps to .NET and leveraging YARP's configuration and Upgrade
  Assistant for a seamless transition.
created: 2023-09-12T23:08:53.979Z
createdBy: Sylvia Huang
createdByEmail: sylviahuang@ssw.com.au
---

The differences between a web app built with ASP.NET Framework and one built with ASP.NET Core are immense. The entire request pipeline underwent significant changes, and can often be impossible to migrate in-place. So how can you tackle these challenges the right way?

<endIntro />

## To YARP, or not to YARP

There exists, somewhere, a line that separates the "big bang" and "stranger fig" approach as being the *recommended* way to tackle web app migrations. While this decision point is unique to every project, you can examine a couple of metrics to help guide your decision.

* How many Sprints do you estimate the migration work will take?
* Will feature development continue during the migration process?
* Do you have plenty of leeway on both of the above?

If your [migration plan](/migration-plans) is solid, you should have a pretty clear idea of the effort involved in migrating your web app. If you're confident that you can get the migration done in a reasonable timeline, *and* you can implement a feature-freeze during that time, opting for the Big Bang approach may be a reasonable option.

If, however, you know that the migration is going to take a long time, or there are other developers/teams that will be working on other, non-migration work (e.g. feature development), then adopting the Strangler Fig pattern with [YARP (Yet Another Reverse Proxy)](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/servers/yarp/getting-started?view=aspnetcore-10.0) is often a better choice, and one that we at SSW have had great success with.

### Create a side-by-side Web App project

The first step is to create a brand new ASP.NET Core web application, where you will be migrating your pages/endpoints into incrementally. For functionalities that have not yet been migrated, YARP will redirect them to the .NET Framework web application.

The best way to do this is via the [GitHub Copilot app modernization Visual Studio extension](https://learn.microsoft.com/en-us/aspnet/core/migration/fx-to-core/tooling?view=aspnetcore-10.0). GitHub Copilot can assist by providing guidance on the necessary configurations for YARP, streamlining the setup process.

### Configure YARP

YARP configuration determines whether a request should be sent to your new ASP.NET Core web app (for routes that have been migrated) or your old .NET Framework web app (for the routes that have not yet been migrated). This can be either defined in the `appsettings.json` file, or provided programmatically with `InMemoryConfigProvider`.

Here's a quick look at a sample YARP route config:

```csharp
RouteConfig[] GetRoutes()
{
    return
    [
        // Route for token
        new RouteConfig()
        {
            RouteId = "tokenServePath",
            ClusterId = tokenClusterId,
            Match = new RouteMatch
            {
                Path = "/token/{**catch-all}",
            },
        },
    
        // Route for WebUI App
        new RouteConfig()
        {
            RouteId = "webUIServePath",
            ClusterId = webUiClusterId,
            Match = new RouteMatch
            {
                Path = "/api/v2/{**catch-all}",
            },
        },
    
        // Route for WebApp App
        new RouteConfig()
        {
            RouteId = "webAppServePath",
            ClusterId = webAppClusterId,
            Match = new RouteMatch
            {
                Path = "/api/{**catch-all}",
            },
        },
    
        // Route for Angular
        new RouteConfig()
        {
            RouteId = "angularUIServePath",
            ClusterId = angularClusterId,
            Match = new RouteMatch
            {
                Path = "{**catch-all}",
            },
        }
    ];
}
```

**Figure: Example code for setting up different paths within YARP's configuration**

### Migrating with GitHub Copilot

Once you have created a side-by-side project, you can start migration by interating with GitHub Copilot following these steps:

1. Open your .NET project or solution that needs migration.
2. Access the GitHub Copilot app modernization agent using one of these methods:
   * Right-click on the solution or project in Solution Explorer and select Modernize.
   * OR open the GitHub Copilot Chat window and type @modernize followed by your upgrade or migration request.
3. Tell the @modernize agent what you want to upgrade or migrate.

Copilot will then run a three-stage workflow, namely the assessment stage, the planning stage and the execution stage. You can find detailed description [here](https://learn.microsoft.com/en-us/dotnet/core/porting/github-copilot-app-modernization/how-to-upgrade-with-github-copilothttps://learn.microsoft.com/en-us/dotnet/core/porting/github-copilot-app-modernization/how-to-upgrade-with-github-copilot).

### Create PBIs to identify the upcoming tasks

When a web project is heavily reliant on .NET Framework dependencies, the first step in gauging the effort required for a complete migration is to thoroughly examine these dependencies. This involves a detailed investigation, followed by the creation of PBIs for each dependency. These PBIs serve to accurately scope out the total effort that will be needed for the migration process.

Listed below are rules crafted to aid in the project migration process. Please ensure to incorporate only those rules that are applicable to your specific project.

* [Do you know how to migrate Global.asax to ASP.NET Core?](/migrate-global-asax-to-asp-net-core)
* [Do you know how to migrate OWIN to ASP.NET Core?](/know-how-to-migrate-owin-to-asp-net-core)
* [Do you know how to migrate Web.config to ASP.NET Core?](/know-how-to-migrate-web-config-to-asp-net-core)
