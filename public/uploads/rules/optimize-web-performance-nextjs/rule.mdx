---
title: Do you optimize web performance in Next.js?
uri: optimize-web-performance-nextjs
categories:
  - category: categories/software-engineering/rules-to-better-websites-development.mdx
  - category: categories/software-engineering/rules-to-better-nextjs.mdx
authors:
  - title: Josh Berman
    url: 'https://ssw.com.au/people/josh-berman'
guid: 9761a722-05db-4b4c-9540-011d5e57a61a
created: 2026-02-09T23:14:44.220Z
createdBy: Josh Berman
createdByEmail: JoshBerman@ssw.com.au
lastUpdated: 2026-02-11T05:33:44.581Z
lastUpdatedBy: Josh Berman
lastUpdatedByEmail: JoshBerman@ssw.com.au
---

Next.js is a popular and powerful framework built on top of React, designed to help teams build fast, scalable web applications.

Without a performance-first approach, applications can quickly become slow due to excessive client-side Javascript, inefficient data fetching or incorrect rendering strategies. Out of the box, Next.js gives you powerful performance tools.

<endIntro />

## Factors That Affect Web Performance

Web performance in Next.js is commonly the result of multiple choices made throughout the application:

* **Rendering strategy** - Choosing between static, server-rendered or dynamic pages directly impacts load time and responsiveness
* **JavaScript sent to the browser** - Larger client bundles increase parse and execution time, delaying interactivity
* **Data fetching patterns** - Client-side fetching often causes request waterfalls, while server-side fetching enables faster initial renders
* **Caching and revalidation** - Explicit caching reduces repeated work and improves response time
* **Images, fonts, and media** - Unoptimized assets are frequently the largest contributor to slow page loads (Impacts Core Web Vitals such as Largest Contentful Paint)
* **Layout stability** - Unexpected layout shifts degrade user experience and negatively impact Cumulative Layout Shift metrics
* **Hydration and interactivity** - Hydrating more UI than necessary increases CPU cost and delays interaction

## Optimizing Web Performance

### 1. Display Images with the built in Next.js Component

Next.js provides an inbuilt [\<Image/>](https://nextjs.org/docs/app/api-reference/components/image) component, which extends the native HTML \<img> element for optimization.

The next/image component automatically optimizes image size, format, and delivery, helping reduce page weight and improve load times. Offscreen images are deferred automatically (lazily loaded), reducing LCP.

<boxEmbed
  body={<>
    For the same image (1920x1080), PNG file size is 800 KB and WebP is 200 KB!
  </>}
  figurePrefix="none"
  figure=""
  style="tips"
/>

Out of the box, the \<Image/> component is pretty straight forward to use.

```ts
<Image
  src="..."
  alt="..."
  width={x-Pixels}
  height={y-Pixels}
  
  //or use fill
  fill
/>
```

Several optional props can further enhance perceived performance and visual stability:

* placeholder - Displays a temporary image while the full asset loads (using blur provides a smoother experience for slower networks
* quality - controls compression level to reduce file size
* priority - Marks critical above-the-fold images for preloading, improves LCP

### 2. Default to Server Components

Next.js allows the user to control the environment where application code can be executed in: the server and the client.

The client refers to the browser on a user's device that sends a request to a server for your application code. Whereas the server refers to the computer in a data center that stores your application code.

Rendering on the server reduces the amount of JavaScript sent to the browser, improves initial load performance and keeps sensitive logic and credentials out of the client bundle.

Client components ('use client') should only be introduced when the UI requires browser only functionality, such as:

* Local states - useState
* Effects- useEffect
* Event Handlers - onClick , onChange
* Direct access to browser APIs - window, document, localStorage

When introducing a Client Component, ensure that you're keeping the client boundary as small as possible and isolate interactivity into focused components.

<boxEmbed
  body={<>
    The client boundary is the point in your React tree where rendering switches from Server â†’ Browser
  </>}
  figurePrefix="none"
  figure=""
  style="info"
/>

### 3. Minimize JavaScript shipped to the browser 

The fastest JavaScript is the JavaScript you don't need to send. Large client bundles increase download size, parse time and execution cost. All of which delays interactivity and Core Web Vitals 

1. Use the @next/bundle-analyzer to get a visual map of everything bundled in your project - this will help identify suspiciously large or necessarily installed dependencies
2. Use dynamic imports - these let you load code only when it's needed (this is great for charts, maps, modals and rich-text editors)
3. Avoid heavy dependencies - do you really need to bundle the entirety of lodash? or can it be replaced with one fn import? 
4. Keep heavy code on the Server - tying in with our previous major point, reduce the usage of the client. 
