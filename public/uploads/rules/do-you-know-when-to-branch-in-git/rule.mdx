---
seoDescription: Do you know when to branch in Git? This guide explains when to create a feature branch and how to merge it back to main, ensuring your project stays organized and deployable at all times.
type: rule
archivedreason:
title: Do you know when to branch in git?
guid: d023678e-aefe-45e8-a4f3-365d4c0f9c93
uri: do-you-know-when-to-branch-in-git
created: 2016-04-05T19:04:31.000Z
authors:
  - title: Adam Cogan
    url: https://ssw.com.au/people/adam-cogan
  - title: Eric Phan
    url: https://ssw.com.au/people/eric-phan
  - title: Danijel Malik
    url: https://ssw.com.au/people/danijel-malik
  - title: Edgar Rocha
    url: https://ssw.com.au/people/edgar-rocha
  - title: Gabriel George
    url: https://ssw.com.au/people/gabriel-george
related:
  - do-you-use-the-best-deployment-tool
  - branch-naming
redirects: []
lastUpdated: 2025-03-04T12:59:32.000Z
lastUpdatedBy: Michelle "MishMannersÂ®â„¢" Duke
lastUpdatedByEmail: 36594527+mishmanners@users.noreply.github.com
createdBy: TiagoAraujo
createdByEmail: TiagoAraujo@ssw.com.au
isArchived: false
---

<introEmbed
  body={<>
The best way to handle continuous development and deployment is following [GitHub Flow](https://guides.github.com/introduction/flow/). The basic idea is to always deploy from **main** , and to create a feature branch for every feature. When the feature is complete, it is merged back to main via a pull request, which provides a trigger for other developers to build.

Using this strategy, **main** is always production-ready and deployable.
  </>}
/>
![Finishing a Feature with World Class Flow](/uploads/rules/do-you-know-when-to-branch-in-git/finishing-a-feature-with-world-class-flow.jpg)

<asideEmbed
  variant="greybox"
  body={<>
    **Note:** This rule applies to git. For branching advice in TFVC, see [when to branch](/do-you-know-when-to-branch).
  </>}
  figureEmbed={{
    preset: "default",
    figure: "XXX",
    shouldDisplay: false
  }}
/>

<youtubeEmbed url="https://www.youtube.com/embed/9bP4-ly2qtQ?rel=0" description={""} />

<imageEmbed
  alt="Image"
  size="large"
  showBorder={false}
  figureEmbed={ {
    preset: "badExample",
    figure: "Bad example - Committing to main",
    shouldDisplay: true
  } }
  src="/uploads/rules/do-you-know-when-to-branch-in-git/commit-master-bad.jpg"
/>

<imageEmbed
  alt="Image"
  size="large"
  showBorder={false}
  figureEmbed={ {
    preset: "goodExample",
    figure: "Good example - Committing to a new branch",
    shouldDisplay: true
  } }
  src="/uploads/rules/do-you-know-when-to-branch-in-git/commit-branch-good.jpg"
/>


<imageEmbed
  alt="Image"
  size="large"
  showBorder={false}
  figureEmbed={ {
    preset: "default",
    figure: "Great diagram from GitHub",
    shouldDisplay: true
  } }
  src="/uploads/rules/do-you-know-when-to-branch-in-git/github-flow.jpg"
/>

### The process

#### Assumption

**Set up build system to deploy from the main branch**

Your build systems should always deploy from main, and should automatically deploy on every commit to main.
Since main is always being deployed, it must always be in a deployable state.

### Step 1 - Create a branch

**a) Create a "feature branch" for every PBI**

When starting a PBI from the task board, create a branch from **main** with a descriptive name for that feature.

```console
git branch start-stuff
```

<figureEmbed figureEmbed={ {
  preset: "badExample",
  figure: "Figure: Bad example - Branch name is not descriptive",
  shouldDisplay: true
} } />


```console
git branch feature/1234-create-basic-web-application
```

<figureEmbed figureEmbed={ {
  preset: "goodExample",
  figure: "Figure: Good example - Branch name describes the intent of the change and follows a [branch naming convention](/branch-naming)",
  shouldDisplay: true
} } />


**It is critical that this branch always comes off main, not another feature branch. Main is the only branch that is mandated to be in a deployable state, so any other option is unsafe.**

Obviously, we're creating a lot of branches and merging a lot under this strategy - and that's ok. Be sure to keep your PBIs small (as per [breaking large tasks into smaller tasks](/estimating-do-you-break-large-tasks-into-smaller-tasks)), and you will not have much merge pain.

The benefit of creating feature branches is to reduce the number of conflicts and churn of unfinished code during development of a feature. It allows features to be developed independently of each other and reduces the amount of expensive "pull latest from the server, and rebuild everything" operations, as well as greatly limiting the impact of commits with unfinished code.

**b) Code away and complete the PBI**

**c) Create a commit - it will contain your changed files on your local PC**

While working, commit frequently to this branch with nice, descriptive messages. For example: _"Added a field to hold the product category to our timesheet read model"_ or _"added a column to the timesheet summary UI for the product category"_.

```console
git commit -m "Started report change"
```

<figureEmbed figureEmbed={ {
  preset: "badExample",
  figure: "Figure: Bad example - Commit message does not describe what was changed",
  shouldDisplay: true
} } />


```console
git commit -m "Added a product category filter to the timesheet summary report UI"
```

<figureEmbed figureEmbed={ {
  preset: "goodExample",
  figure: "Figure: Good example - Commit message describes exactly what was changed",
  shouldDisplay: true
} } />


**d) Push your changes to your remote Feature Branch**

### Step 2 - Open a pull request (to merge from your current branch to the main)

When the change is complete, or when you want feedback on anything, open a pull request to merge the branch back to **main**. The pull request is more than just a request to merge, it is a request to have someone review the code and architecture, or image and to discuss any issues. Resolve these issues with more commits in the branch before continuing.

**Tip:** A best practice is to have another developer review your work and then approve.

<asideEmbed
  variant="greybox"
  body={<>
    It is easy to chalk this step up as busy-work, but it is one of the most valuable parts of the strategy.
  </>}
  figureEmbed={{
    preset: "default",
    figure: "XXX",
    shouldDisplay: false
  }}
/>

#### Assumption

Deploy the changes to a staging environment. This allows the features to be tested before being merged to **main**.

Some prefer to move this step to after the merge, especially when using a release management tool like VSTS Release or Octopus Deploy (see [Do you use the best deployment tool](/do-you-use-the-best-deployment-tool)). If you decide to go this route, remember that **main** should remain deployable and production ready at all times and that all branches come from **main**. If skipping this step, ensure that you have CI on your feature branch to ensure that your branch compiles and passes all tests before merging.

### Step 3 - Merge and Deploy (to main)

Once everyone is happy and everything is tested, complete the pull request, which will merge back to **main**. Ensure you are not using the "Fast Forward" merge option (git), or details about the branch will be lost - it will appear as though all work was done in **main**. Being able to see the feature branches in the git log is very useful.

<imageEmbed
  alt="Image"
  size="large"
  showBorder={false}
  figureEmbed={ {
    preset: "goodExample",
    figure: "Good example - Each change is well described, small and in its own feature branch",
    shouldDisplay: true
  } }
  src="/uploads/rules/do-you-know-when-to-branch-in-git/GoodGitHistory.png"
/>

After you completed the pull request, make sure you also delete the branch that you made the pull request of. Deleting your completed branch will not just help yourself in the long run, but also everyone else. Having too many branches especially a stale one will confuse developers on what "may" be in progress, moreover it would cause so much pain to the future developer when they have to do a clean-up and the branch author has left.

<imageEmbed
  alt="Image"
  size="large"
  showBorder={false}
  figureEmbed={ {
    preset: "badExample",
    figure: "Bad example - Lots of stale branches that could cause confusion or potentially take a long time to resolve conflicts when merging",
    shouldDisplay: true
  } }
  src="/uploads/rules/do-you-know-when-to-branch-in-git/bad-figure-stale-branches2.png"
/>

Otherwise, you can do it before you complete the pull request by ticking delete branch option.

<imageEmbed
  alt="Image"
  size="large"
  showBorder={false}
  figureEmbed={ {
    preset: "goodExample",
    figure: "Good example - Automatically delete the branch after the pull request completion in Azure Devops",
    shouldDisplay: true
  } }
  src="/uploads/rules/do-you-know-when-to-branch-in-git/delete-branch-in-devops.png"
/>

<imageEmbed
  alt="Image"
  size="large"
  showBorder={false}
  figureEmbed={ {
    preset: "goodExample",
    figure: "Good example - Set the whole project to auto-delete branch after merging in GitHub",
    shouldDisplay: true
  } }
  src="/uploads/rules/do-you-know-when-to-branch-in-git/github-settings.png"
/>

<asideEmbed
  variant="greybox"
  body={<>
    Once merged, **main** should immediately and automatically be deployed (in a perfect world, to production).
  </>}
  figureEmbed={{
    preset: "default",
    figure: "XXX",
    shouldDisplay: false
  }}
/>
