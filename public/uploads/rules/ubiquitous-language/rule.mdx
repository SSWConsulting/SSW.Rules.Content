---
archivedreason: null
authors:
- title: Matt Goldman
  url: https://ssw.com.au/people/matt-goldman
categories:
- category: categories/software-engineering/rules-to-better-domain-driven-design.mdx
created: 2024-11-05 00:00:00+00:00
guid: f8555180-50c2-423e-84e2-d73a9018222f
related:
- rule: public/uploads/rules/encapsulate-domain-models/rule.mdx
- rule: public/uploads/rules/use-specification-pattern/rule.mdx
- rule: public/uploads/rules/anemic-vs-rich-domain-models/rule.mdx
- rule: public/uploads/rules/consistent-words-for-concepts/rule.mdx
- rule: public/uploads/rules/avoid-micro-jargon/rule.mdx
- rule: public/uploads/rules/when-to-use-technical-names/rule.mdx
seoDescription: We often use ours or our company name to denote a custom version of
  something. Unless you're publishing a library, this is never a good idea.
title: Do you use ubiquitous language?
type: rule
uri: ubiquitous-language
---

Ubiquitous language is a core principle in domain-driven design (DDD) that encourages developers and stakeholders to use the same vocabulary when discussing business logic and domain concepts. By using a shared, domain-specific language across code, documentation, and conversations, you ensure that everyone has a common understanding of core concepts. This approach reduces misunderstandings and makes the codebase more accessible to those familiar with the business domain.

<endOfIntro />

## Why Ubiquitous Language Matters
Ubiquitous language helps bridge the gap between technical and non-technical stakeholders, creating a consistent and clear understanding of the domain. When everyone uses the same terms ‚Äî whether in code, documentation, or discussions ‚Äî it‚Äôs easier to align on requirements, troubleshoot issues, and onboard new team members. Without it, terms can become muddled, causing confusion and misinterpretation.


<boxEmbed
  style="greybox"
  body={<>
    Let‚Äôs say you‚Äôre working on an insurance system, and the domain term ‚Äúpolicyholder‚Äù is used consistently among stakeholders. However, in the codebase, you see different terms used interchangeably: `AccountOwner`, `Customer`, and `InsuredParty`. Each of these terms could technically represent the policyholder, but the inconsistency can lead to confusion and misunderstandings about the exact role of each entity.
  </>}
  captionStyle="badExample"
  captionText={"Terms in the code do not reflect domain language used by stakeholders"}
/>



<boxEmbed
  style="greybox"
  body={<>
    To follow ubiquitous language, you would use `PolicyHolder` consistently across the codebase, aligning the code‚Äôs vocabulary with the language used by domain experts. This approach eliminates ambiguity, making it clear that `PolicyHolder` refers to the specific entity recognized by all stakeholders.
  </>}
  captionStyle="goodExample"
  captionText={"Ubiquitous language is used, and developers and stakeholders are on the same page"}
/>


### Benefits
* **Improved Communication:** By using the same terms as domain experts, developers and stakeholders communicate more effectively, reducing the risk of misinterpretation.
* **Increased Readability:** Consistent terminology makes it easier for anyone familiar with the domain to understand the codebase.
* **Enhanced Maintenance:** When domain terms are used uniformly, developers spend less time deciphering concepts and more time building functionality.


<boxEmbed
  style="greybox"
  body={<>
    üí° **Tip:** You can use the [Contextive](https://github.com/dev-cycles/contextive) extension for IntelliJ and VS Code (other IDEs coming soon) to assist with this. The linked repo also has a discussion between Chris Simon (the author) and [SSW's Gert Marx](https://www.ssw.com.au/people/gert-marx/) about both the extension and ubiquitous language in general
  </>}
  captionStyle="default"
  captionText={""}
/>