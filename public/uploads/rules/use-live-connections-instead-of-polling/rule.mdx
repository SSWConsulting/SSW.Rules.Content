---
title: Do you use live connections instead of polling?
uri: use-live-connections-instead-of-polling
guid: a578f4a5-4a3b-4b4e-b05c-f4ee8334db6a
created: 2026-02-04 21:45:20.670000
createdBy: Hajir Lesani [SSW]
createdByEmail: hajir2005@gmail.com
authors:
- author: hajir-lesani
categories:
- category: categories/software-engineering/rules-to-better-web-api.mdx
seoDescription: Learn why you should use live connections (SignalR, WebSockets, SSE)
  instead of polling for real-time data updates, and when simpler approaches are acceptable.
type: rule
---
When your application needs real-time data updates, you have several options: polling, webhooks, or live connections. Polling - where clients repeatedly request data at intervals - is often the first solution developers reach for, but it's usually the worst choice for real-time scenarios.

Studies show that **98.5% of polling requests are wasted** - they return no new data. This "Polling Madness" wastes server resources, increases costs, and still doesn't provide true real-time updates.

<endIntro _hidden="" />

## Why polling is problematic

Imagine 10,000 users polling your API every 5 seconds. That's **10,000 requests per second** your server must handle - even when there's nothing new to report. With live connections, you'd only send data when something actually changes.

**Polling problems:**

* Wastes server resources (98.5% of requests return nothing new)
* Creates artificial latency (users wait for the next poll interval)
* Scales poorly (more users = exponentially more requests)
* Drains mobile device batteries
* Increases infrastructure costs

**Live connections benefits:**

* Push data only when changes occur
* True real-time updates (sub-second latency)
* Scales efficiently
* Better battery life for mobile apps
* Lower infrastructure costs

## Choosing the right technology

| Technology | Direction | Best For |
|------------|-----------|----------|
| **SignalR** | Bidirectional | .NET apps needing broad compatibility, automatic fallbacks, and easy scaling |
| **WebSockets** | Bidirectional | Maximum performance, gaming, trading platforms, custom protocols |
| **SSE** | Server to Client | Simple notifications, live feeds, dashboards (no binary data) |
| **Webhooks** | Server to Server | Service-to-service communication, third-party integrations |

### When to use SignalR

SignalR is the recommended choice for .NET applications. It automatically selects the best transport (WebSockets, SSE, or Long Polling) and provides:

* Automatic reconnection handling
* Built-in group messaging (broadcast to specific users/rooms)
* Multiple scaling options (Redis, Azure Service Bus, SQL Server)
* Cross-platform client SDKs

```csharp
// Bad - Polling for updates
public class DashboardController : Controller
{
    [HttpGet("api/dashboard/stats")]
    public async Task<IActionResult> GetStats()
    {
        // Client calls this every 5 seconds - wasteful!
        var stats = await _statsService.GetCurrentStats();
        return Ok(stats);
    }
}

// Client-side polling
setInterval(async () => {
    const response = await fetch('/api/dashboard/stats');
    const stats = await response.json();
    updateDashboard(stats);
}, 5000);
```

**❌ Figure: Bad example - Polling wastes resources even when nothing has changed**

```csharp
// Good - SignalR Hub for real-time updates
public class DashboardHub : Hub
{
    public async Task SubscribeToDashboard(string dashboardId)
    {
        await Groups.AddToGroupAsync(Context.ConnectionId, $"dashboard-{dashboardId}");
    }
}

// Service that pushes updates only when data changes
public class StatsService
{
    private readonly IHubContext<DashboardHub> _hubContext;

    public async Task UpdateStats(string dashboardId, DashboardStats stats)
    {
        // Only sends when there's actually new data
        await _hubContext.Clients.Group($"dashboard-{dashboardId}")
            .SendAsync("StatsUpdated", stats);
    }
}
```

**✅ Figure: Good example - SignalR pushes updates only when data actually changes**

### When to use Server-Sent Events (SSE)

SSE is perfect when you only need **server-to-client** communication and want zero dependencies:

* Live notifications
* Activity feeds
* Stock tickers
* Log streaming

```csharp
// Good - SSE for simple server-to-client streaming
[HttpGet("api/notifications/stream")]
public async Task StreamNotifications(CancellationToken cancellationToken)
{
    Response.Headers.Append("Content-Type", "text/event-stream");
    Response.Headers.Append("Cache-Control", "no-cache");

    await foreach (var notification in _notificationService
        .GetNotificationsAsync(cancellationToken))
    {
        await Response.WriteAsync($"data: {JsonSerializer.Serialize(notification)}\n\n");
        await Response.Body.FlushAsync();
    }
}
```

**✅ Figure: Good example - SSE provides a lightweight option for unidirectional streaming**

### When to use raw WebSockets

Use WebSockets directly when you need:

* Maximum performance with minimal overhead
* Binary data transmission (games, media streaming)
* Custom protocols or message formats
* Non-.NET clients where SignalR isn't available

## When live connections are overkill

Live connections add complexity. Sometimes they're not worth it.

<boxEmbed
  body={<>
    **Tip:** Do not over-engineer. If users only need updates every few minutes and real-time is not critical, a simple refresh button or periodic polling with proper caching might be the right choice.
  </>}
  figurePrefix="none"
  figure=""
  style="tips"
/>

**Consider simpler alternatives when:**

* **Updates are infrequent** - If data changes hourly or daily (e.g., daily reports, software update checks), scheduled polling or manual refresh is fine
* **Near real-time is acceptable** - A 30-second delay does not impact the user experience (e.g., email inbox, social media feeds)
* **The app is internal with few users** - 5 users polling every 10 seconds is just 30 requests/minute - hardly a scaling concern
* **You are building a prototype or MVP** - Get it working first, optimize later when you have real usage data
* **Infrastructure does not support WebSockets** - Some corporate proxies, firewalls, or legacy systems block WebSocket connections

| Scenario | Recommendation |
|----------|----------------|
| Chat application with instant messages | **SignalR** - Users expect instant delivery |
| Dashboard updated every 30 seconds | **Polling** - Acceptable latency, simpler implementation |
| Live sports scores | **SignalR/SSE** - Real-time is the product |
| Admin panel with 3 users | **Polling** - Over-engineering to use live connections |
| Stock trading platform | **WebSockets** - Milliseconds matter |
| Blog comments | **Polling** - Updates are infrequent |
| Collaborative document editing | **SignalR** - Multiple users editing simultaneously |
| Background job status | **SSE** - Simple server-to-client push |

## Quick decision flowchart

Ask yourself these questions:

1. **Do users need updates instantly (less than 1 second)?** - Use SignalR or WebSockets
2. **Is it server-to-client only?** - Consider SSE for simplicity
3. **Are you in the .NET ecosystem?** - SignalR is the default choice
4. **Do you need maximum performance/binary data?** - Raw WebSockets
5. **Is near real-time (30+ seconds) acceptable?** - Polling is fine
6. **Is this an MVP or prototype?** - Start simple, optimize later

## Scaling considerations

Live connections maintain persistent server connections, which introduces state into your web tier. When scaling horizontally:

* **SignalR**: Use a backplane (Redis, Azure Service Bus, or SQL Server)
* **Azure SignalR Service**: Managed service that handles scaling automatically
* **WebSockets**: Configure load balancers for sticky sessions or use a message broker

```csharp
// Program.cs - Configuring SignalR with Redis backplane for scaling
builder.Services.AddSignalR()
    .AddStackExchangeRedis(connectionString, options =>
    {
        options.Configuration.ChannelPrefix = RedisChannel.Literal("MyApp");
    });
```

**✅ Figure: Good example - Configure a backplane when scaling SignalR horizontally**

## Summary

| Choose | When |
|--------|------|
| **SignalR** | .NET app, need real-time, want automatic fallbacks and easy scaling |
| **WebSockets** | Maximum performance, binary data, custom protocols, non-.NET |
| **SSE** | Simple server-to-client push, no dependencies needed |
| **Polling** | Updates are infrequent, near real-time is OK, or building an MVP |

## Further reading

* [Introduction to SignalR | Microsoft Learn](https://learn.microsoft.com/en-us/aspnet/signalr/overview/getting-started/introduction-to-signalr)
* [SignalR vs WebSocket comparison | Ably](https://ably.com/topic/signalr-vs-websocket)
* [Server-Sent Events in ASP.NET Core | Roxeem](https://roxeem.com/2025/10/24/a-pragmatic-guide-to-server-sent-events-sse-in-asp-net-core/)
* [Stop Polling and Consider Using REST Hooks | Nordic APIs](https://nordicapis.com/stop-polling-and-consider-using-rest-hooks/)
* [Webhooks vs Polling | Merge](https://www.merge.dev/blog/webhooks-vs-polling)
